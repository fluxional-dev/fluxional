{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\ude80 AWS Serverless Development All In Python \ud83d\udc0d","text":"<p>On-Going Documentation</p> <p>This documentation is a work in progress. If you have any questions or need help, please reach out to us. Join our \ud83d\udc49 Discord</p> <p>Fluxional is designed to simplify the development and deployment of serverless applications on AWS with minimal configuration.</p> <p>Key features:</p> <ul> <li>Simplified infrastructure syntax</li> <li>Deployment only require credentials and docker</li> <li>Live interaction with your cloud application as you code</li> <li>Focused on developer experience with intuitive syntax and editor / type support</li> </ul> <p></p> <p></p> 1) Infrastructure is simplified and part of your code  \ud83d\ude0e Rest API\ud83d\udcf2 Websockets\ud83d\udd10 Databases\ud83e\udea3 Storage (S3)\ud83d\udeb6 Async Events\ud83d\udd75\ufe0f Tasks app.py<pre><code>from fluxional import Fluxional, ApiEvent, LambdaContext\n\nflux = Fluxional(\"Backend\")\n\n@flux.api\ndef my_api(event: ApiEvent, context: LambdaContext):\n    return {\"statusCode\": 200, \"body\": \"ok\"}\n\nhandler = flux.handler()\n</code></pre> app.py<pre><code>from fluxional import Fluxional, WsEvent, LambdaContext, Websocket\n\nflux = Fluxional(\"Backend\")\n\n@flux.websocket.on_connect\ndef connect(event: WsEvent, context: LambdaContext):\n    return {\"statusCode\": 200}\n\n@flux.websocket.on(\"some_action\")\ndef on_action(event: WsEvent, context: LambdaContext):\n    # Reply to the sender\n    Websocket.post_to_connection(event, \"Hello World!\")\n\nhandler = flux.handler()\n</code></pre> app.py<pre><code>from fluxional import Fluxional\n\nflux = Fluxional(\"Backend\")\n\nflux.add_dynamodb() # \ud83d\udc48 This will create a dynamodb\n</code></pre> app.py<pre><code>from fluxional import Fluxional, StorageEvent, LambdaContext\n\nflux = Fluxional(\"Backend\")\n\n@flux.storage.on_upload\ndef on_upload(event: StorageEvent, context: LambdaContext):\n    # Do something when a file is uploaded\n\nhandler = flux.handler()\n</code></pre> app.py<pre><code>from fluxional import Fluxional, LambdaContext, Event\n\nflux = Fluxional(\"Backend\")\n\nevent = Event[str]()\n\n@flux.event\ndef on_event(payload: str, context: LambdaContext):\n    # Do something when an event is triggered\n\ndef trigger_event():\n    # Trigger on_event with str payload\n    event.trigger(\"on_event\", \"Hello World!\")\n\nhandler = flux.handler()\n</code></pre> app.py<pre><code>from fluxional import Fluxional, TaskEvent, LambdaContext\n\nflux = Fluxional(\"Backend\")\n\n@flux.run.every(1, \"days\")\ndef task_1(event: TaskEvent, context: LambdaContext):\n    # Do something every day from now\n\nhandler = flux.handler()\n</code></pre> <p></p>  2) Deploy without installing and managing Node, Aws Cli &amp; CDK versions <ul> <li> <p>Fluxional provides a containarized deployment flow. No need to install and Manage versions of Node, AWS Cli or CDK on your machine \u26d4.   Provide your credentials in a .env and you are good to go \ud83d\ude0a.</p> </li> <li> <p>Your AWS Lambda functions are containerized and dockerfiles are auto-generated \ud83d\ude0e based on the runtime, requirements and dependencies you need.</p> </li> </ul> <p>To deploy \ud83d\ude80 your application:</p> <pre><code>$ fluxional deploy app.handler\n</code></pre> <p>To remove \ud83d\udd28 your application:</p> <pre><code>$ fluxional destroy app.handler\n</code></pre> <p></p>  3) Live Development- Interact with your microservice as you code  <ul> <li>Invoke your microservice locally \ud83d\udcbb and make live changes \ud83d\udd58 without the need to mock your services or re-deploy.</li> <li>Your code will be ran in a local container with the exact \u2728 environment and behaviors your application will have in the cloud.</li> </ul> <p>** Setting must be enabled and deployed before executing below. </p> <pre><code>$ fluxional dev app.handler\n</code></pre> <p></p>"},{"location":"concepts/","title":"\u2728 Concepts","text":"<p>Fluxional is an abstraction layer over commonly used aws libraries such as Boto3 and AWS CDK. It provides a simple and intuitive interface to create and deploy serverless applications on AWS.</p>"},{"location":"concepts/#1-the-setup-phase","title":"1) The setup phase","text":"<p>Minimal Host Dependencies and No managing versions of iac, nodes, cli etc... all in docker with a single command.</p> <p>Provide your credentials directly to fluxional and it will take care of the rest in a container.</p> <pre><code>from fluxional import Fluxional\n\nfluxional = Fluxional(\"Backend\")\n\n# All of these are automatically fetched from your .env file\nfluxional.configure(\n    aws_account_id=...,\n    aws_region=...,\n    aws_access_key_id=...,\n    aws_secret_access_key=...,\n)\n</code></pre>"},{"location":"concepts/#2-the-dev-phase","title":"2) The dev phase","text":"<p>Let's look at deploying a simple Rest-API that returns hello world</p> The fluxional wayThe traditional way <p>One file is all you need</p> <pre><code>from fluxional import Fluxional, ApiEvent, LambdaContext\n\nflx = Fluxional(\"Backend\")\n\n@flx.api\ndef hello(event: ApiEvent, context: LambdaContext):\n    return {\"statusCode\": 200, \"body\": \"Hello World\"}\n\nhandler = flx.handler()\n</code></pre> <p>Write your handler</p> <pre><code>def handler(event: ApiEvent, context: LambdaContext):\n    return {\"statusCode\": 200, \"body\": \"Hello World\"}\n</code></pre> <p>Write your dockerfile</p> <pre><code>FROM public.ecr.aws/lambda/python:3.10\n\nCOPY app.py requirements.txt ./\n\nRUN pip install -r requirements.txt -t .\n\nCMD [\"app.handler\"]\n</code></pre> <p>Write your IAC</p> <pre><code>from aws_cdk import ...\n\nlambda_function = aws_lambda.Function(\n        self,\n        id=SERVICE_NAME + \"_lambda\",\n        description=SERVICE_NAME + \"_lambda\",\n        code=ecr_image,\n        handler=aws_lambda.Handler.FROM_IMAGE,\n        runtime=aws_lambda.Runtime.FROM_IMAGE,\n        function_name=SERVICE_NAME,\n        memory_size=128,\n        timeout=Duration.seconds(900),\n    )\n\n# ETC...\n</code></pre>"},{"location":"concepts/#3-4-5-testing-deployment-testing","title":"3-4-5) Testing, Deployment, Testing...","text":"<p>We have all been there, unit tests work, integration tests with local mocks works, we deploy and wait for a minute. And then an unexpected error occurs such as say Cors, forgotten permissions.  Now we wait for another minute to deploy and so on and so forth. Fluxional accelerate this by allowing to develop with a live lambda with the exact environment. This work is inspired by the developers at sst.</p>"},{"location":"get_started/async_events/","title":"Async Events","text":"app.py<pre><code>from fluxional import Fluxional, Event, AsyncEvent, LambdaContext\n\nflux = Fluxional(\"AwesomeProject\")\nevent = Event()\n\n@flux.event\ndef resize_image(event: AsyncEvent, context: LambdaContext):\n    # Do something asynchronously\n\ndef run_event():\n    event.trigger(\"resize_image\", payload={...})\n\nhandler = flux.handler()\n</code></pre>"},{"location":"get_started/deployment/","title":"Deployment","text":"<p>To deploy \ud83d\ude80 your application:</p> <pre><code>$ fluxional deploy app.handler\n</code></pre> <p>To remove \ud83d\udd28 your application:</p> <pre><code>$ fluxional destroy app.handler\n</code></pre>  (More Coming Soon...)"},{"location":"get_started/first_steps/","title":"First Steps","text":""},{"location":"get_started/first_steps/#install-fluxional-via-pip","title":"Install Fluxional Via Pip","text":"<pre><code>pip install fluxional\n</code></pre> <p>Create a main entry app.py file. Import Fluxional and declare an instance of the app with a unique id (CamelCase) across the aws account, in this case \"GetStarted\":</p> app.py<pre><code>from fluxional import Fluxional\n\nflux = Fluxional(\"GetStarted\")\n</code></pre> <p>Now you can start to define your services using decorators; in this case a rest api. This will generate at deployment time an api gateway and a lambda function integration and everything in between.</p> app.py<pre><code>from fluxional import Fluxional, ApiEvent, LambdaContext\n\nflux = Fluxional(\"GetStarted\")\n\n@flux.api\ndef my_api(event: ApiEvent, context: LambdaContext):\n    return {\"statusCode\": 200, \"body\": \"ok\"}\n</code></pre> <p>Then once finished we need to include our entrypoint handler</p> app.py<pre><code>from fluxional import Fluxional, ApiEvent, LambdaContext\n\nflux = Fluxional(\"GetStarted\")\n\n@flux.api\ndef my_api(event: ApiEvent, context: LambdaContext):\n    return {\"statusCode\": 200, \"body\": \"ok\"}\n\nhandler = flux.handler()\n</code></pre> <p>Create a .env file containing the following variables:</p> <pre><code>AWS_ACCESS_KEY_ID=...\nAWS_SECRET_ACCESS_KEY=...\nAWS_DEFAULT_REGION=...\nAWS_ACCOUNT_ID=...\n</code></pre> <p>Put your dependencies in a \"requirements.txt\" in your root folder, your project should now look like this</p> <pre><code>\u251c\u2500\u2500 app.py\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 requirements.txt\n</code></pre> <p>To deploy your application run the following command by pointing to the handler:</p> <pre><code>$ fluxional deploy app.handler\n</code></pre> <p>And voil\u00e0! Your application is now deployed and ready to use. Lookout for the output url in the console.</p> <p>To destroy your application run:</p> <pre><code>$ fluxional destroy app.handler\n</code></pre>"},{"location":"get_started/live_development/","title":"Live Development","text":"<p>This work is inspired by the developers at sst.</p> <p>Enable the following setting in your code:</p> <pre><code>flux.settings.development.enable_local = True\n</code></pre> <p>Deploy your application:</p> <pre><code>$ fluxional deploy app.handler\n</code></pre> <p>Run your dev environment with</p> <pre><code>$ fluxional dev app.handler\n</code></pre> <p></p> <p>(More Coming Soon...)</p>"},{"location":"get_started/multiple_files/","title":"Multiple Files","text":"api.py<pre><code>from fluxional import Extender, ApiEvent, LambdaContext\n\nflux = Extender()\n\n@flux.api\ndef api_event(event: ApiEvent, context: LambdaContext):\n    return {\"statusCode\": 200}\n</code></pre> main.py<pre><code>from fluxional import Fluxional\nfrom api import flux as api_flux\n\nflux = Fluxional(\"AwesomeProject\")\n\nflux.configure(\n    dependencies=[\"api.py\"] # include the api file\n)\nflux.register(api_flux) # register the resource\n\nhandler = flux.handler()\n</code></pre>"},{"location":"get_started/requirements/","title":"Requirements","text":""},{"location":"get_started/requirements/#python-version-required-310","title":"Python version required: 3.10+","text":""},{"location":"get_started/requirements/#docker","title":"Docker","text":"<p>Visit the official docker website \ud83d\udc0b at this link on how to install on your system.</p>"},{"location":"get_started/requirements/#aws-credentials","title":"AWS Credentials","text":"<p>You will need to create a new user in AWS IAM and get the following:</p> <ul> <li>Access Key ID</li> <li>Secret Access Key</li> <li>Region</li> <li>Account ID</li> </ul> <p>For development purposes use the following policy on your AWS user. For production always use the least privilege principle when creating policies or use more secure methods. (See)</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\"sts:AssumeRole\"],\n      \"Resource\": [\"arn:aws:iam::*:role/cdk-*\"]\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\"iot:Connect\", \"iot:DescribeEndpoint\"],\n      \"Resource\": [\"*\"]\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\"iot:Publish\", \"iot:Receive\"],\n      \"Resource\": \"arn:aws:iot:*:*:topic/fluxional*\"\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": \"iot:Subscribe\",\n      \"Resource\": \"arn:aws:iot:*:*:topicfilter/fluxional*\"\n    }\n  ]\n}\n</code></pre>"},{"location":"get_started/rest_api/","title":"Rest API","text":"<p>All HTTP requests \u2708\ufe0f will be proxied to your functions, so you have the freedom to implement any framework \ud83c\udf89 that you want.</p>"},{"location":"get_started/rest_api/#example","title":"Example","text":"As DecoratorAs Inline app.py<pre><code>from fluxional import Fluxional, ApiEvent, LambdaContext\n\nflux = Fluxional(\"MyApp\")\n\n@flux.api\ndef hello_world(event: ApiEvent, context: LambdaContext):\n    return {\"statusCode\": 200, \"body\": \"Hello World\"}\n\nhandler = flux.handler()\n</code></pre> app.py<pre><code>from fluxional import Fluxional, ApiEvent, LambdaContext\n\nflux = Fluxional(\"MyApp\")\n\ndef hello_world(event: ApiEvent, context: LambdaContext):\n    return {\"statusCode\": 200, \"body\": \"Hello World\"}\n\nflux.add_api(hello_world)\n\nhandler = flux.handler()\n</code></pre>"},{"location":"get_started/rest_api/#settings","title":"Settings","text":"<p>You can modify your lambda and api gateway settings \ud83d\udee0\ufe0f through the settings property. By default \ud83e\udd17 Fluxional will always use the minimum settings required to deploy \ud83d\ude80 your application.</p> app.py<pre><code>from fluxional import Fluxional\n\nflux = Fluxional(\"MyApp\")\nsettings = flux.settings.build\n\nsettings.api_lambda.memory_size = 128\nsettings.api_lambda.timeout = 30\nsettings.api_lambda.description = \"My lambda function\"\n\nsettings.api_gateway.stage_name = \"dev\"\nsettings.api_gateway.description = \"My api gateway\"\nsettings.api_gateway.deploy = True\nsettings.api_gateway.endpoint_type = \"regional\"\n</code></pre>"},{"location":"get_started/settings/","title":"Settings & Resources","text":"settings.py<pre><code>from fluxional import Settings\n\nsettings = Settings()\n\n# Your settings ...\nsettings.build.api_lambda.memory = 128\n</code></pre> main.py<pre><code>from fluxional import Fluxional\nfrom settings import settings\n\nflux = Fluxional(\"AwesomeProject\")\n\nflux.configure(\n    dependencies=[\"settings.py\"] # include the settings file\n)\nflux.set_settings(settings) # register the settings\n\nhandler = flux.handler()\n</code></pre>"},{"location":"get_started/storage/","title":"Storage (S3)","text":"app.py<pre><code>from fluxional import Fluxional, StorageEvent, LambdaContext\n\nflux = Fluxional(\"Backend\")\n\n@flux.storage.on_upload\ndef upload_event(event: StorageEvent, context: LambdaContext):\n    ...\n\n@flux.storage.on_delete\ndef delete_event(event: StorageEvent, context: LambdaContext):\n    ...\n\nhandler = flux.handler()\n</code></pre> <p>If you are not using the reactive functions, you need to enable the storage explicitly to create a storage.</p> app.py<pre><code>from fluxional import Fluxional, Storage, Environment\n\nflux = Fluxional(\"Backend\")\nenv = Environment()\n\n# Enable storage\nflux.settings.storage.enable = True\n\n# Access bucket name at deployment time\nbucket_name = env.storage_bucket_name\n\nhandler = flux.handler()\n</code></pre>"},{"location":"get_started/tasks/","title":"Tasks","text":"app.py<pre><code>from fluxional import Fluxional, TaskEvent, LambdaContext\n\nflux = Fluxional(\"AwesomeProject\")\n\n@flux.run.every(1, \"days\")\ndef task_1(event: TaskEvent, context: LambdaContext):\n    # Runs every day from deployment\n\n@flux.run.every(1, \"hours\")\ndef task_2(event: TaskEvent, context: LambdaContext):\n    # Runs every hour from deployment\n\n@flux.run.every(5, \"minutes\")\ndef task_3(event: TaskEvent, context: LambdaContext):\n    # Runs every 5 minutes from deployment\n\nhandler = flux.handler()\n</code></pre> app.py<pre><code>from fluxional import Fluxional, TaskEvent, LambdaContext\n\nflux = Fluxional(\"AwesomeProject\")\n\n@flx.run.on(hour=\"3\", minute=\"20\")\ndef task_1(event: TaskEvent, context: LambdaContext):\n    # Runs at 3:20 UTC every day\n\n@flx.run.on(hour=\"3\", minute=\"20\", day_of_week=\"mon\")\ndef task_2(event: TaskEvent, context: LambdaContext):\n    # Runs at 3:20 UTC every Monday\n\nhandler = flux.handler()\n</code></pre>"},{"location":"get_started/websockets/","title":"Websockets","text":"app.py<pre><code>from fluxional import Fluxional, WsEvent, LambdaContext\n\nflux = Fluxional(\"AwesomeProject\")\n\n@flux.websocket.on_connect\ndef connect(event: WsEvent, context: LambdaContext):\n    ...\n\n@flux.websocket.on(\"some_action\")\ndef on_action(event: WsEvent, context: LambdaContext):\n    ...\n\nhandler = flux.handler()\n</code></pre>"},{"location":"get_started/databases/dynamodb/","title":"Dynamodb","text":"<p>Here is an example of implementing a DynamoDB table using Fluxional.</p> app.py<pre><code>from fluxional import Fluxional\n\nflux = Fluxional(\"AwesomeProject\")\n\nflux.add_dynamodb(\n    remove_on_delete=True, # When destroying the stack, the table will be deleted\n    partition_key={\"key_name\": \"pk\", \"key_type\": \"string\"},\n    sort_key={\"key_name\": \"sk\", \"key_type\": \"number\"},\n    local_secondary_indexes=[\n        {\n            \"index_name\": \"local_index\",\n            \"sort_key\": {\"key_name\": \"local_sk\", \"key_type\": \"string\"},\n        }\n    ],\n    global_secondary_indexes=[\n        {\n            \"index_name\": \"global_index\",\n            \"partition_key\": {\"key_name\": \"global_pk\", \"key_type\": \"string\"},\n            \"sort_key\": {\"key_name\": \"global_sk\", \"key_type\": \"string\"},\n        }\n    ],\n)\n</code></pre>"},{"location":"get_started/monitoring/opentelemetry/","title":"\ud83d\udd2d Open Telemetry","text":"<p>Opentelemetry can be enabled by using the following settings:</p> <pre><code>from fluxional import Settings\n\nsettings = Settings()\n\nsettings.monitoring.otel.enable = True\nsettings.monitoring.otel.endpoint = \"http://your-endpoint\"\nsettings.monitoring.otel.service_name = \"your-service-name\"\nsettings.monitoring.otel.exporter_otlp_headers = \"some-headers=here\"\n</code></pre> <p>This will send your traces / metrics to your desired observability platform using the http/protobuf protocol.</p>"}]}